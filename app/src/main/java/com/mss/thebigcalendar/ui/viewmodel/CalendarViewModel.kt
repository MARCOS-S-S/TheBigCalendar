package com.mss.thebigcalendar.ui.viewmodel

import android.app.Application
import android.content.ContentValues.TAG
import android.content.Intent
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.tasks.Task
import com.mss.thebigcalendar.data.model.Activity
import com.mss.thebigcalendar.data.model.ActivityType
import com.mss.thebigcalendar.data.model.CalendarDay
import com.mss.thebigcalendar.data.model.CalendarFilterOptions
import com.mss.thebigcalendar.data.model.CalendarUiState
import com.mss.thebigcalendar.data.model.Holiday
import com.mss.thebigcalendar.data.model.SearchResult
import com.mss.thebigcalendar.data.model.Theme
import com.mss.thebigcalendar.data.model.ViewMode

import com.mss.thebigcalendar.data.repository.ActivityRepository
import com.mss.thebigcalendar.data.repository.HolidayRepository
import com.mss.thebigcalendar.data.repository.SettingsRepository
import com.mss.thebigcalendar.service.GoogleAuthService
import com.mss.thebigcalendar.service.GoogleCalendarService
import com.mss.thebigcalendar.service.NotificationService
import com.mss.thebigcalendar.service.SearchService
import com.mss.thebigcalendar.service.RecurrenceService
import com.mss.thebigcalendar.data.repository.DeletedActivityRepository
import com.mss.thebigcalendar.data.repository.CompletedActivityRepository
import com.mss.thebigcalendar.data.service.BackupService
import com.mss.thebigcalendar.data.service.BackupInfo
import com.mss.thebigcalendar.service.VisibilityService
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.YearMonth
import java.time.ZoneId
import java.time.ZoneOffset
import java.time.temporal.ChronoUnit
import java.util.UUID
import androidx.work.WorkManager
import androidx.work.PeriodicWorkRequestBuilder
import androidx.compose.material3.MaterialTheme
import androidx.compose.ui.graphics.Color
import androidx.work.Constraints
import androidx.work.NetworkType
import com.mss.thebigcalendar.service.ProgressiveSyncService
import com.mss.thebigcalendar.worker.GoogleCalendarSyncWorker
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.delay
import kotlinx.coroutines.Job

class CalendarViewModel(application: Application) : AndroidViewModel(application) {

    val settingsRepository = SettingsRepository(application)
    private val activityRepository = ActivityRepository(application)
    private val holidayRepository = HolidayRepository(application)
    private val googleAuthService = GoogleAuthService(application)
    private val googleCalendarService = GoogleCalendarService(application)
    private val progressiveSyncService = ProgressiveSyncService(application, googleCalendarService)
    private val searchService = SearchService()
    private val recurrenceService = RecurrenceService()
    private val deletedActivityRepository = DeletedActivityRepository(application)
    private val completedActivityRepository = CompletedActivityRepository(application)
    private val backupService = BackupService(application, activityRepository, deletedActivityRepository, completedActivityRepository)
    private val visibilityService = VisibilityService(application)

    // Debounce para otimizar atualiza√ß√µes do calend√°rio
    private var updateJob: Job? = null
    
    // Cache para evitar rec√°lculos desnecess√°rios do calend√°rio
    private var cachedCalendarDays: List<CalendarDay>? = null
    private var lastUpdateParams: String? = null
    
    // Cache para anivers√°rios por data
    private var cachedBirthdays: Map<LocalDate, List<Activity>> = emptyMap()
    private var cachedNotes: Map<LocalDate, List<Activity>> = emptyMap()
    private var cachedTasks: Map<LocalDate, List<Activity>> = emptyMap()

    private val _uiState = MutableStateFlow(CalendarUiState())
    val uiState: StateFlow<CalendarUiState> = _uiState.asStateFlow()

    init {
        loadSettings()
        loadData()
        checkForExistingSignIn()
        // Garantir que o calend√°rio inicie no m√™s atual
        onGoToToday()
        
        // Registrar broadcast receiver para atualiza√ß√µes de notifica√ß√µes
        registerNotificationBroadcastReceiver()
    }

    override fun onCleared() {
        super.onCleared()
        // Limpar job pendente quando o ViewModel for destru√≠do
        updateJob?.cancel()
        // Limpar cache
        clearCalendarCache()
        // Desregistrar broadcast receiver
        try {
            getApplication<Application>().unregisterReceiver(notificationBroadcastReceiver)
        } catch (e: Exception) {
            // Ignorar erro se o receiver n√£o estiver registrado
        }
    }
    
    private val notificationBroadcastReceiver = object : android.content.BroadcastReceiver() {
        override fun onReceive(context: android.content.Context?, intent: android.content.Intent?) {
            if (intent?.action == "com.mss.thebigcalendar.ACTIVITY_COMPLETED") {
                val activityId = intent.getStringExtra("activity_id")
                if (activityId != null) {
                    Log.d("CalendarViewModel", "üîî Recebido broadcast de atividade conclu√≠da: $activityId")
                    // Atualizar a UI
                    updateAllDateDependentUI()
                }
            }
        }
    }
    
    private fun registerNotificationBroadcastReceiver() {
        val filter = android.content.IntentFilter("com.mss.thebigcalendar.ACTIVITY_COMPLETED")
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            getApplication<Application>().registerReceiver(notificationBroadcastReceiver, filter, android.content.Context.RECEIVER_NOT_EXPORTED)
        } else {
            getApplication<Application>().registerReceiver(notificationBroadcastReceiver, filter)
        }
    }

    /**
     * Gera uma chave √∫nica baseada nos par√¢metros que afetam o calend√°rio
     * A data selecionada n√£o afeta o cache do calend√°rio, apenas a exibi√ß√£o dos detalhes
     */
    private fun generateCalendarCacheKey(): String {
        val state = _uiState.value
        return buildString {
            append("${state.displayedYearMonth}_")
            // Removido selectedDate - n√£o afeta o cache do calend√°rio
            append("${state.filterOptions.showHolidays}_")
            append("${state.filterOptions.showSaintDays}_")
            append("${state.filterOptions.showEvents}_")
            append("${state.filterOptions.showTasks}_")
            append("${state.filterOptions.showNotes}_")
            append("${state.filterOptions.showBirthdays}_")
            append("${state.showCompletedActivities}_")
            append("${state.showMoonPhases}_")
            append("${state.activities.size}_")
            append("${state.completedActivities.size}_")
            append("${state.nationalHolidays.size}_")
            append("${state.saintDays.size}")
        }
    }

    /**
     * Limpa o cache do calend√°rio quando necess√°rio
     * O cache deve ser limpo apenas quando:
     * - O m√™s/ano exibido muda
     * - As atividades/feriados mudam
     * - Os filtros mudam
     * - O ViewModel √© destru√≠do
     * N√ÉO deve ser limpo quando apenas a data selecionada muda
     */
    private fun clearCalendarCache() {
        cachedCalendarDays = null
        lastUpdateParams = null
    }
    
    private fun clearActivityCache() {
        cachedBirthdays = emptyMap()
        cachedNotes = emptyMap()
        cachedTasks = emptyMap()
    }

    private fun checkForExistingSignIn() {
        val account = googleAuthService.getLastSignedInAccount()
        if (account != null) {
            _uiState.update { it.copy(googleSignInAccount = account) }
            fetchGoogleCalendarEvents(account)
        }
    }
    


    fun onSignInClicked() {
        val signInIntent = googleAuthService.getSignInIntent()
        _uiState.update { it.copy(signInIntent = signInIntent) }
    }

    fun onSignInLaunched() {
        _uiState.update { it.copy(signInIntent = null) }
    }

    fun handleSignInResult(task: Task<GoogleSignInAccount>) {
        val account = googleAuthService.handleSignInResult(task)
        val loginSuccess = account != null
        _uiState.update { it.copy(
            googleSignInAccount = account,
            loginMessage = if(loginSuccess) "Login bem-sucedido!" else "Falha no login. Verifique os logs para detalhes."
        ) }
        if (loginSuccess) {
            fetchGoogleCalendarEvents(account!!)
        } else {
            android.util.Log.w("CalendarViewModel", "Sign-in failed, not fetching events.")
        }
    }

    fun clearLoginMessage() {
        _uiState.update { it.copy(loginMessage = null) }
    }

    fun signOut() {
        googleAuthService.signOut {
            _uiState.update { it.copy(googleSignInAccount = null) }
            viewModelScope.launch {
                activityRepository.deleteAllActivitiesFromGoogle()
            }
        }
    }

    /**
     * Detecta se um evento do Google Calendar √© um anivers√°rio baseado em caracter√≠sticas espec√≠ficas
     */
    private fun detectBirthdayEvent(event: com.google.api.services.calendar.model.Event): Boolean {
        val title = event.summary?.lowercase() ?: ""
        val description = event.description?.lowercase() ?: ""
        val isAllDay = event.start?.dateTime == null
        val hasRecurrence = event.recurrence?.isNotEmpty() == true
        
        // Palavras-chave para detectar anivers√°rios (em portugu√™s e ingl√™s)
        val birthdayKeywords = listOf(
            "birthday", "anivers√°rio", "nascimento", "nasc", "bday", "b-day",
            "feliz anivers√°rio", "happy birthday", "completa anos", "turns",
            "aniversariante", "birthday boy", "birthday girl", "aniversariantes",
            "parab√©ns", "congratulations", "festa", "party", "celebration"
        )
        
        // Verificar se o t√≠tulo ou descri√ß√£o cont√©m palavras-chave de anivers√°rio
        val hasBirthdayKeywords = birthdayKeywords.any { keyword ->
            title.contains(keyword) || description.contains(keyword)
        }
        
        // Verificar se √© um evento recorrente anual (t√≠pico de anivers√°rios)
        val isYearlyRecurring = event.recurrence?.any { rule ->
            rule.contains("FREQ=YEARLY") || rule.contains("RRULE:FREQ=YEARLY") ||
            rule.contains("INTERVAL=1") && rule.contains("FREQ=YEARLY")
        } == true
        
        // Verificar se √© um evento de dia inteiro (anivers√°rios geralmente s√£o)
        val isAllDayEvent = isAllDay
        
        // Verificar se tem configura√ß√µes espec√≠ficas de anivers√°rio do Google
        val hasBirthdaySettings = event.gadget?.preferences?.any { (key, value) ->
            key == "googCalEventType" && value == "birthday"
        } == true
        
        // Verificar se vem de um calend√°rio espec√≠fico de anivers√°rios
        val isFromBirthdayCalendar = event.organizer?.email?.contains("birthday") == true ||
                                   event.creator?.email?.contains("birthday") == true
        
        // Verificar se tem padr√µes espec√≠ficos de anivers√°rio no t√≠tulo
        val hasBirthdayPatterns = title.matches(Regex(".*\\b\\d{1,2}/\\d{1,2}\\b.*")) || // Padr√£o DD/MM
                                 title.matches(Regex(".*\\b\\d{1,2}-\\d{1,2}\\b.*")) || // Padr√£o DD-MM
                                 title.matches(Regex(".*\\b\\d{1,2}\\.\\d{1,2}\\b.*"))   // Padr√£o DD.MM
        
        // Um evento √© considerado anivers√°rio se:
        // 1. Cont√©m palavras-chave de anivers√°rio, OU
        // 2. √â recorrente anual E √© de dia inteiro, OU  
        // 3. Tem configura√ß√µes espec√≠ficas de anivers√°rio do Google, OU
        // 4. Vem de um calend√°rio de anivers√°rios, OU
        // 5. Tem padr√µes de data no t√≠tulo (t√≠pico de anivers√°rios)
        val result = hasBirthdayKeywords || 
                    (isYearlyRecurring && isAllDayEvent) || 
                    hasBirthdaySettings ||
                    isFromBirthdayCalendar ||
                    hasBirthdayPatterns
        
        return result
    }
    
    /**
     * Cria anivers√°rios de exemplo para teste se nenhum for detectado automaticamente
     */
    private fun createSampleBirthdays() {
        viewModelScope.launch {
            val currentYear = LocalDate.now().year
            val sampleBirthdays = listOf(
                Activity(
                    id = "sample_birthday_1",
                    title = "Jo√£o Silva - Anivers√°rio",
                    description = "Anivers√°rio do Jo√£o Silva",
                    date = "$currentYear-03-15",
                    startTime = null,
                    endTime = null,
                    isAllDay = true,
                    location = null,
                    categoryColor = "#FF69B4",
                    activityType = ActivityType.BIRTHDAY,
                    recurrenceRule = "YEARLY",
                    showInCalendar = true,
                    isFromGoogle = false
                ),
                Activity(
                    id = "sample_birthday_2",
                    title = "Maria Santos - Anivers√°rio",
                    description = "Anivers√°rio da Maria Santos",
                    date = "$currentYear-07-22",
                    startTime = null,
                    endTime = null,
                    isAllDay = true,
                    location = null,
                    categoryColor = "#FF69B4",
                    activityType = ActivityType.BIRTHDAY,
                    recurrenceRule = "YEARLY",
                    showInCalendar = true,
                    isFromGoogle = false
                )
            )
            
            // Salvar os anivers√°rios de exemplo
            activityRepository.saveAllActivities(sampleBirthdays)
            
            // Atualizar a UI
            updateAllDateDependentUI()
        }
    }

    private fun fetchGoogleCalendarEvents(account: GoogleSignInAccount, forceSync: Boolean = false) {
        viewModelScope.launch {
            _uiState.update { it.copy(isSyncing = true, syncErrorMessage = null) }
            try {
                val currentTime = System.currentTimeMillis()
                val lastSync = _uiState.value.lastGoogleSyncTime
                val timeSinceLastSync = currentTime - lastSync
                
                // Sincroniza√ß√£o di√°ria: s√≥ sincronizar se passou mais de 24 horas (a menos que seja for√ßada)
                if (!forceSync && timeSinceLastSync < 24 * 60 * 60 * 1000) {
                    _uiState.update { it.copy(isSyncing = false) }
                    return@launch
                }
                
                // N√ÉO deletar eventos existentes at√© os novos chegarem - isso evita o "flash"
                // Os eventos antigos ser√£o substitu√≠dos pelos novos ao final

                // 2. Fetch new events from Google Calendar
                val calendarService = googleCalendarService.getCalendarService(account)
                
                // Buscar eventos do calend√°rio principal
                val primaryEvents = withContext(Dispatchers.IO) {
                    calendarService.events().list("primary").execute()
                }
                
                // Buscar eventos de contatos (que cont√™m anivers√°rios)
                val contactEvents = withContext(Dispatchers.IO) {
                    try {
                        calendarService.events().list("contacts").execute()
                    } catch (e: Exception) {
                        // Se n√£o conseguir acessar o calend√°rio de contatos, usar lista vazia
                        com.google.api.services.calendar.model.Events()
                    }
                }
                
                // Buscar eventos de anivers√°rios espec√≠ficos
                val birthdayCalendarEvents = withContext(Dispatchers.IO) {
                    try {
                        calendarService.events().list("birthdays").execute()
                    } catch (e: Exception) {
                        // Se n√£o conseguir acessar o calend√°rio de anivers√°rios, usar lista vazia
                        com.google.api.services.calendar.model.Events()
                    }
                }
                
                // Combinar todos os eventos
                val allEvents = mutableListOf<com.google.api.services.calendar.model.Event>()
                allEvents.addAll(primaryEvents.items ?: emptyList())
                allEvents.addAll(contactEvents.items ?: emptyList())
                allEvents.addAll(birthdayCalendarEvents.items ?: emptyList())
                
                val events = com.google.api.services.calendar.model.Events().apply {
                    items = allEvents
                }

                // 3. Map them to the app's Activity model
                val activities = events.items.mapNotNull { event ->
                    // Ignore events without a start date
                    val start = event.start?.dateTime?.value ?: event.start?.date?.value ?: return@mapNotNull null
                    val end = event.end?.dateTime?.value ?: event.end?.date?.value

                    // Tratar eventos de dia inteiro (como anivers√°rios) de forma diferente
                    val startDate = if (event.start?.dateTime == null) {
                        // Para eventos de dia inteiro, usar UTC para evitar problemas de fuso hor√°rio
                        // O Google Calendar envia eventos de dia inteiro no in√≠cio do dia UTC
                        val utcDate = Instant.ofEpochMilli(start).atZone(ZoneOffset.UTC).toLocalDate()
                        utcDate
                    } else {
                        // Para eventos com hor√°rio, usar fuso hor√°rio local
                        val localDate = Instant.ofEpochMilli(start).atZone(ZoneId.systemDefault()).toLocalDate()
                        localDate
                    }
                    
                    val startTime = if (event.start?.dateTime != null) Instant.ofEpochMilli(start).atZone(ZoneId.systemDefault()).toLocalTime() else null
                    val endTime = if (end != null && event.end?.dateTime != null) Instant.ofEpochMilli(end).atZone(ZoneId.systemDefault()).toLocalTime() else null

                    // Detectar se √© um anivers√°rio baseado em caracter√≠sticas espec√≠ficas
                    val isBirthday = detectBirthdayEvent(event)
                    
                    Activity(
                        id = event.id ?: UUID.randomUUID().toString(),
                        title = event.summary ?: "Sem t√≠tulo",
                        description = event.description,
                        date = startDate.toString(),
                        startTime = startTime,
                        endTime = endTime,
                        isAllDay = event.start?.dateTime == null,
                        location = event.location,
                        categoryColor = if (isBirthday) "#FF69B4" else "#4285F4", // Rosa para anivers√°rios, Azul para eventos
                        activityType = if (isBirthday) ActivityType.BIRTHDAY else ActivityType.EVENT,
                        recurrenceRule = event.recurrence?.firstOrNull(),
                        showInCalendar = true, // Por padr√£o, mostrar no calend√°rio
                        isFromGoogle = true
                    )
                }
                
                // Log das estat√≠sticas de sincroniza√ß√£o
                val totalEvents = activities.size
                val birthdayEvents = activities.count { it.activityType == ActivityType.BIRTHDAY }
                val regularEvents = activities.count { it.activityType == ActivityType.EVENT }
                
                // 4. Fazer merge dos eventos (manter existentes + adicionar novos)
                val currentActivities = activityRepository.activities.first()
                activities.forEach { newActivity ->
                    // Verificar se j√° existe uma atividade com o mesmo ID
                    val existingActivity = currentActivities.find { it.id == newActivity.id }
                    if (existingActivity != null) {
                        // Se j√° existe, preservar a cor personalizada do usu√°rio
                        val updatedActivity = newActivity.copy(categoryColor = existingActivity.categoryColor)
                        activityRepository.saveActivity(updatedActivity)
                    } else {
                        // Se n√£o existe, adicionar nova com cor padr√£o
                        activityRepository.saveActivity(newActivity)
                    }
                }
                
                // 5. Atualizar a UI ap√≥s salvar as atividades
                updateAllDateDependentUI()
                
                // 6. Atualizar timestamp de √∫ltima sincroniza√ß√£o
                _uiState.update { it.copy(lastGoogleSyncTime = currentTime) }
                
                // 7. Verificar se h√° anivers√°rios e criar alguns de exemplo se necess√°rio
                if (birthdayEvents == 0) {
                    Log.w("CalendarViewModel", "‚ö†Ô∏è Nenhum anivers√°rio detectado automaticamente. Criando anivers√°rios de exemplo...")
                    createSampleBirthdays()
                }

            } catch (e: Exception) {
                Log.e("CalendarViewModel", "Error fetching Google Calendar events", e)
                _uiState.update { it.copy(syncErrorMessage = "Falha ao sincronizar eventos.") }
            } finally {
                _uiState.update { it.copy(isSyncing = false) }
            }
        }
    }

    private fun loadSettings() {
        viewModelScope.launch {
            settingsRepository.theme.collect { theme ->
                _uiState.update { it.copy(theme = theme) }
            }
        }
        viewModelScope.launch {
            settingsRepository.welcomeName.collect { welcomeName ->
                _uiState.update { it.copy(welcomeName = welcomeName) }
            }
        }
        viewModelScope.launch {
            settingsRepository.filterOptions.collect { filterOptions ->
                _uiState.update { it.copy(filterOptions = filterOptions) }
                updateAllDateDependentUI()
            }
        }
        viewModelScope.launch {
            settingsRepository.showMoonPhases.collect { showMoonPhases ->
                _uiState.update { it.copy(showMoonPhases = showMoonPhases) }
            }
        }
        viewModelScope.launch {
            // Observar o estado de login do Google e o nome de boas-vindas
            _uiState.collect { uiState ->
                val googleAccount = uiState.googleSignInAccount
                val currentWelcomeName = uiState.welcomeName

                if (googleAccount != null && currentWelcomeName == "Usu√°rio") {
                    val firstName = googleAccount.displayName?.split(" ")?.firstOrNull()
                    if (!firstName.isNullOrBlank()) {
                        settingsRepository.saveWelcomeName(firstName)
                    }
                }
            }
        }
    }


    
    private fun loadData() {
        // Carregar apenas as atividades do m√™s atual
        loadActivitiesForCurrentMonth()
        
        viewModelScope.launch {
            deletedActivityRepository.deletedActivities.collect { deletedActivities ->
                _uiState.update { it.copy(deletedActivities = deletedActivities) }
            }
        }
        
        viewModelScope.launch {
            completedActivityRepository.completedActivities.collect { completedActivities ->
                _uiState.update { it.copy(completedActivities = completedActivities) }
                // Limpar cache quando as atividades completadas mudam
                clearCalendarCache()
                // Usar debounce para evitar m√∫ltiplas atualiza√ß√µes r√°pidas
                updateAllDateDependentUI()
            }
        }
        
        loadInitialHolidaysAndSaints()
    }

    /**
     * Carrega apenas as atividades do m√™s atual
     * Otimiza√ß√£o para reduzir uso de mem√≥ria e melhorar performance
     */
    private fun loadActivitiesForCurrentMonth() {
        val currentMonth = _uiState.value.displayedYearMonth
        
        viewModelScope.launch {
            activityRepository.getActivitiesForMonth(currentMonth).collect { activities ->
                _uiState.update { it.copy(activities = activities) }
                
                // Limpar cache quando as atividades mudam
                clearCalendarCache()
                clearActivityCache()
                // Usar debounce para evitar m√∫ltiplas atualiza√ß√µes r√°pidas
                updateAllDateDependentUI()
            }
        }
    }

    /**
     * Atualiza as atividades quando o m√™s muda
     */
    private fun updateActivitiesForNewMonth(newMonth: YearMonth) {
        viewModelScope.launch {
            activityRepository.getActivitiesForMonth(newMonth).collect { activities ->
                _uiState.update { it.copy(activities = activities) }
                
                // Limpar cache quando as atividades mudam
                clearCalendarCache()
                clearActivityCache()
                // Atualizar o calend√°rio
                updateAllDateDependentUI()
            }
        }
    }

    private fun loadInitialHolidaysAndSaints() {
        viewModelScope.launch {
            val nationalHolidaysList = holidayRepository.getNationalHolidays()
            val saintDaysList = holidayRepository.getSaintDays()

            _uiState.update { currentState ->
                currentState.copy(
                    nationalHolidays = nationalHolidaysList.associateBy { LocalDate.parse(it.date) },
                    saintDays = saintDaysList.associateBy { it.date }
                )
            }
            // Limpar cache quando os feriados mudam
            clearCalendarCache()
            // N√£o chamar updateCalendarDays() aqui para evitar loop infinito
            // updateCalendarDays() ser√° chamado por updateAllDateDependentUI()
        }
    }
    


    private fun updateCalendarDays() {
        val state = _uiState.value
        
        // Verificar se podemos usar o cache
        val currentCacheKey = generateCalendarCacheKey()
        if (cachedCalendarDays != null && lastUpdateParams == currentCacheKey) {
            // Usar cache - n√£o recalculamos
            return
        }
        
        // Cache miss - precisamos recalcular

        val firstDayOfMonth = state.displayedYearMonth.atDay(1)
        val daysFromPrevMonthOffset = (firstDayOfMonth.dayOfWeek.value % 7)
        val gridStartDate = firstDayOfMonth.minusDays(daysFromPrevMonthOffset.toLong())

        val newCalendarDays = List(42) { i ->
            val date = gridStartDate.plusDays(i.toLong())
            
            // Coletar todas as atividades para este dia (incluindo repetitivas)
            val allActivitiesForThisDay = mutableListOf<Activity>()
            
            val tasksForThisDay = if (state.filterOptions.showTasks || state.filterOptions.showEvents || state.filterOptions.showNotes || state.filterOptions.showBirthdays) {
                
                state.activities.forEach { activity ->
                    try {
                        val activityDate = LocalDate.parse(activity.date)
                        val typeMatches = (state.filterOptions.showTasks && activity.activityType == ActivityType.TASK) ||
                                (state.filterOptions.showEvents && activity.activityType == ActivityType.EVENT) ||
                                (state.filterOptions.showNotes && activity.activityType == ActivityType.NOTE) ||
                                (state.filterOptions.showBirthdays && activity.activityType == ActivityType.BIRTHDAY)
                        
                        if (typeMatches) {
                            // Para anivers√°rios, verificar se √© o mesmo dia e m√™s (ignorando o ano)
                            val dateMatches = if (activity.activityType == ActivityType.BIRTHDAY) {
                                activityDate.month == date.month && activityDate.dayOfMonth == date.dayOfMonth
                            } else {
                                activityDate.isEqual(date)
                            }
                            
                            if (dateMatches) {
                                // Verificar se a atividade deve aparecer no calend√°rio
                                val shouldShowInCalendar = activity.showInCalendar
                                
                                // Para atividades recorrentes, verificar se esta data espec√≠fica foi exclu√≠da
                                val isExcluded = if (activity.recurrenceRule?.isNotEmpty() == true && activity.recurrenceRule != "CUSTOM") {
                                    activity.excludedDates.contains(date.toString())
                                } else {
                                    false
                                }
                                
                                if (shouldShowInCalendar && !isExcluded) {
                                    allActivitiesForThisDay.add(activity)
                                }
                            }
                            
                            // Se a atividade √© repetitiva, calcular se deve aparecer neste dia
                            if (activity.recurrenceRule?.isNotEmpty() == true && 
                                activity.recurrenceRule != "CUSTOM" && 
                                activity.showInCalendar) {
                                
                                val recurringInstances = calculateRecurringInstancesForDate(activity, date)
                                allActivitiesForThisDay.addAll(recurringInstances)
                            }
                        }
                    } catch (e: Exception) {
                        // Erro ao processar atividade - continuar com outras atividades
                    }
                }
                
                // Adicionar tarefas finalizadas se a op√ß√£o estiver ativada
                if (state.showCompletedActivities) {
                    state.completedActivities.forEach { completedActivity ->
                        try {
                            val activityDate = LocalDate.parse(completedActivity.date)
                            val dateMatches = activityDate.isEqual(date)
                            
                            if (dateMatches) {
                                allActivitiesForThisDay.add(completedActivity)
                            }
                        } catch (e: Exception) {
                            // Erro ao processar tarefa finalizada - continuar com outras
                        }
                    }
                }
                
                // Incluir tarefas finalizadas na lista final se a op√ß√£o estiver ativada
                val finalTasksList = if (state.showCompletedActivities) {
                    allActivitiesForThisDay.sortedWith(compareByDescending<Activity> { it.categoryColor?.toIntOrNull() ?: 0 }.thenBy { it.startTime ?: LocalTime.MIN })
                } else {
                    // Filtrar apenas atividades n√£o finalizadas
                    allActivitiesForThisDay.filter { !it.isCompleted }.sortedWith(compareByDescending<Activity> { it.categoryColor?.toIntOrNull() ?: 0 }.thenBy { it.startTime ?: LocalTime.MIN })
                }
                
                finalTasksList
            } else {
                emptyList()
            }

            val holidayForThisDay = if (state.filterOptions.showHolidays) state.nationalHolidays[date] else null
            val saintDayForThisDay = if (state.filterOptions.showSaintDays) state.saintDays[date.format(java.time.format.DateTimeFormatter.ofPattern("MM-dd"))] else null

            CalendarDay(
                date = date,
                isCurrentMonth = date.month == state.displayedYearMonth.month,
                isSelected = date.isEqual(state.selectedDate),
                isToday = date.isEqual(LocalDate.now()),
                tasks = tasksForThisDay,
                holiday = holidayForThisDay ?: saintDayForThisDay,
                isWeekend = date.dayOfWeek == java.time.DayOfWeek.SATURDAY || date.dayOfWeek == java.time.DayOfWeek.SUNDAY,
                isNationalHoliday = holidayForThisDay?.type == com.mss.thebigcalendar.data.model.HolidayType.NATIONAL,
                isSaintDay = saintDayForThisDay != null
            )
        }
        
        // Salvar no cache
        cachedCalendarDays = newCalendarDays
        lastUpdateParams = currentCacheKey
        
        _uiState.update { it.copy(calendarDays = newCalendarDays) }
    }

    private fun updateTasksForSelectedDate() {
        val state = _uiState.value
        
        // Separar anivers√°rios das outras atividades usando cache
        val birthdays = if (state.filterOptions.showBirthdays) {
            cachedBirthdays[state.selectedDate] ?: run {
                val filtered = state.activities.filter { activity ->
                    try {
                        if (activity.activityType == ActivityType.BIRTHDAY) {
                            val activityDate = LocalDate.parse(activity.date)
                            // Para anivers√°rios, verificar se √© o mesmo dia e m√™s (ignorando o ano)
                            activityDate.month == state.selectedDate.month && activityDate.dayOfMonth == state.selectedDate.dayOfMonth
                        } else {
                            false
                        }
                    } catch (e: Exception) {
                        false
                    }
                }.sortedBy { it.title }
                
                // Atualizar cache
                cachedBirthdays = cachedBirthdays + (state.selectedDate to filtered)
                filtered
            }
        } else {
            emptyList()
        }
        
        // Separar notas das outras atividades usando cache
        val notes = if (state.filterOptions.showNotes) {
            cachedNotes[state.selectedDate] ?: run {
                val filtered = state.activities.filter { activity ->
                    try {
                        if (activity.activityType == ActivityType.NOTE) {
                            val activityDate = LocalDate.parse(activity.date)
                            activityDate.isEqual(state.selectedDate)
                        } else {
                            false
                        }
                    } catch (e: Exception) {
                        false
                    }
                }.sortedBy { it.title }
                
                // Atualizar cache
                cachedNotes = cachedNotes + (state.selectedDate to filtered)
                filtered
            }
        } else {
            emptyList()
        }
        
        // Filtrar outras atividades (excluindo anivers√°rios e notas)
        // Coletar todas as tarefas para o dia selecionado (incluindo repetitivas)
        val allTasksForSelectedDate = mutableListOf<Activity>()
        
        state.activities.forEach { activity ->
            try {
                if (activity.activityType == ActivityType.BIRTHDAY || activity.activityType == ActivityType.NOTE) {
                    // Pular anivers√°rios e notas
                    return@forEach
                }
                
                val activityDate = LocalDate.parse(activity.date)
                val typeMatches = (state.filterOptions.showTasks && activity.activityType == ActivityType.TASK) ||
                        (state.filterOptions.showEvents && activity.activityType == ActivityType.EVENT)
                
                if (typeMatches) {
                    // Verificar se a atividade deve aparecer no calend√°rio
                    // NOTA: Para a se√ß√£o de agendamentos, n√£o aplicamos o filtro showInCalendar
                    // pois queremos que todas as tarefas apare√ßam aqui, mesmo as que n√£o s√£o mostradas no calend√°rio
                    
                    val dateMatches = activityDate.isEqual(state.selectedDate)
                    if (dateMatches) {
                        // Para atividades recorrentes, verificar se esta data espec√≠fica foi exclu√≠da
                        val isExcluded = if (activity.recurrenceRule?.isNotEmpty() == true && activity.recurrenceRule != "CUSTOM") {
                            activity.excludedDates.contains(state.selectedDate.toString())
                        } else {
                            false
                        }
                        
                        if (!isExcluded) {
                            allTasksForSelectedDate.add(activity)
                        }
                    }
                    
                    // Se a atividade √© repetitiva, calcular se deve aparecer neste dia
                    if (activity.recurrenceRule?.isNotEmpty() == true && 
                        activity.recurrenceRule != "CUSTOM") {
                        
                        val recurringInstances = calculateRecurringInstancesForDate(activity, state.selectedDate)
                        allTasksForSelectedDate.addAll(recurringInstances)
                        
                    }
                }
            } catch (e: Exception) {
                // Erro ao processar atividade - continuar com outras
            }
        }
        
        // Adicionar tarefas finalizadas se a op√ß√£o estiver ativada
        if (state.showCompletedActivities) {
            state.completedActivities.forEach { completedActivity ->
                try {
                    val activityDate = LocalDate.parse(completedActivity.date)
                    val dateMatches = activityDate.isEqual(state.selectedDate)
                    
                    if (dateMatches) {
                        allTasksForSelectedDate.add(completedActivity)
                    }
                } catch (e: Exception) {
                    // Erro ao processar tarefa finalizada - continuar com outras
                }
            }
        }
        
        val otherTasks = allTasksForSelectedDate.sortedWith(
            compareByDescending<Activity> { it.categoryColor?.toIntOrNull() ?: 0 }
            .thenBy { it.startTime ?: LocalTime.MIN }
        )
        
        // Atualizar todas as listas
        _uiState.update { 
            it.copy(
                tasksForSelectedDate = otherTasks,
                birthdaysForSelectedDate = birthdays,
                notesForSelectedDate = notes
            ) 
        }
    }

    private fun updateHolidaysForSelectedDate() {
        val state = _uiState.value
        val holidays = if (state.filterOptions.showHolidays) {
            state.nationalHolidays[state.selectedDate]?.let { listOf(it) } ?: emptyList()
        } else {
            emptyList()
        }
        _uiState.update { it.copy(holidaysForSelectedDate = holidays) }
    }

    private fun updateSaintDaysForSelectedDate() {
        val state = _uiState.value
        val saints = if (state.filterOptions.showSaintDays) {
            val monthDay = state.selectedDate.format(java.time.format.DateTimeFormatter.ofPattern("MM-dd"))
            state.saintDays[monthDay]?.let { listOf(it) } ?: emptyList()
        } else {
            emptyList()
        }
        _uiState.update { it.copy(saintDaysForSelectedDate = saints) }
    }

    private fun updateAllDateDependentUI() {
        // Cancelar atualiza√ß√£o anterior se ainda estiver pendente
        updateJob?.cancel()
        
        // Agendar nova atualiza√ß√£o com debounce de 100ms
        updateJob = viewModelScope.launch {
            delay(100) // Debounce de 100ms
            updateCalendarDays()
            updateTasksForSelectedDate()
            updateHolidaysForSelectedDate()
            updateSaintDaysForSelectedDate()
        }
    }

    /**
     * Atualiza apenas a propriedade isSelected dos dias do calend√°rio
     * sem recriar todo o cache - otimiza√ß√£o para mudan√ßa de data selecionada
     * 
     * Esta otimiza√ß√£o permite que o dia selecionado seja marcado visualmente
     * sem invalidar o cache do calend√°rio, mantendo a performance
     */
    private fun updateSelectedDateInCalendar() {
        val state = _uiState.value
        val updatedCalendarDays = state.calendarDays.map { day ->
            day.copy(isSelected = day.date.isEqual(state.selectedDate))
        }
        _uiState.update { it.copy(calendarDays = updatedCalendarDays) }
    }

    fun onPreviousMonth() {
        val newMonth = _uiState.value.displayedYearMonth.minusMonths(1)
        _uiState.update { it.copy(displayedYearMonth = newMonth) }
        // Carregar atividades do novo m√™s
        updateActivitiesForNewMonth(newMonth)
    }

    fun onNextMonth() {
        val newMonth = _uiState.value.displayedYearMonth.plusMonths(1)
        _uiState.update { it.copy(displayedYearMonth = newMonth) }
        // Carregar atividades do novo m√™s
        updateActivitiesForNewMonth(newMonth)
    }

    fun onPreviousYear() {
        _uiState.update { it.copy(displayedYearMonth = it.displayedYearMonth.minusYears(1)) }
    }

    fun onNextYear() {
        _uiState.update { it.copy(displayedYearMonth = it.displayedYearMonth.plusYears(1)) }
    }

    fun onGoToToday() {
        val currentState = _uiState.value
        val today = LocalDate.now()
        val currentMonth = YearMonth.now()
        val monthChanged = currentState.displayedYearMonth != currentMonth
        
        _uiState.update {
            it.copy(
                displayedYearMonth = currentMonth,
                selectedDate = today
            )
        }
        
        // Se o m√™s mudou, carregar atividades do novo m√™s
        if (monthChanged) {
            updateActivitiesForNewMonth(currentMonth)
        } else {
            // Se apenas o dia mudou, apenas atualizar a data selecionada
            updateSelectedDateInCalendar()
        }
    }

    fun onDateSelected(date: LocalDate) {
        val state = _uiState.value
        val shouldOpenModal = state.selectedDate.isEqual(date) && date.month == state.displayedYearMonth.month
        val monthChanged = state.displayedYearMonth.month != date.month || state.displayedYearMonth.year != date.year

        _uiState.update {
            it.copy(
                selectedDate = date,
                displayedYearMonth = if (monthChanged) {
                    YearMonth.from(date)
                } else {
                    it.displayedYearMonth
                },
                activityIdWithDeleteButtonVisible = null // Esconde o bot√£o ao selecionar nova data
            )
        }
        
        if (monthChanged) {
            // Se o m√™s mudou, carregar atividades do novo m√™s
            val newMonth = YearMonth.from(date)
            updateActivitiesForNewMonth(newMonth)
        } else {
            // Se apenas a data selecionada mudou, atualizar apenas a marca√ß√£o visual
            updateSelectedDateInCalendar()
            updateTasksForSelectedDate()
            updateHolidaysForSelectedDate()
            updateSaintDaysForSelectedDate()
        }

        if (shouldOpenModal) {
            openCreateActivityModal()
        }
    }

    fun onYearlyMonthClicked(yearMonth: YearMonth) {
        val currentState = _uiState.value
        val monthChanged = currentState.displayedYearMonth != yearMonth
        
        _uiState.update {
            it.copy(
                displayedYearMonth = yearMonth,
                selectedDate = yearMonth.atDay(1),
                viewMode = ViewMode.MONTHLY,
                isSidebarOpen = false
            )
        }
        
        // Se o m√™s mudou, carregar atividades do novo m√™s
        if (monthChanged) {
            updateActivitiesForNewMonth(yearMonth)
        }
    }

    fun onViewModeChange(newMode: ViewMode) {
        _uiState.update { it.copy(viewMode = newMode, isSidebarOpen = false) }
    }

    fun onFilterChange(key: String, value: Boolean) {
        when (key) {
            "showCompletedActivities" -> {
                // Atualizar o estado imediatamente
                _uiState.update { it.copy(showCompletedActivities = value) }
                
                // Atualizar a UI
                updateAllDateDependentUI()
            }
            "showMoonPhases" -> {
                // Atualizar o estado imediatamente
                _uiState.update { it.copy(showMoonPhases = value) }
                
                // Salvar a configura√ß√£o
                viewModelScope.launch {
                    settingsRepository.saveShowMoonPhases(value)
                }
            }
            else -> {
                val currentFilters = _uiState.value.filterOptions
                val newFilters = when (key) {
                    "showHolidays" -> currentFilters.copy(showHolidays = value)
                    "showSaintDays" -> currentFilters.copy(showSaintDays = value)
                    "showEvents" -> currentFilters.copy(showEvents = value)
                    "showTasks" -> currentFilters.copy(showTasks = value)
                    "showNotes" -> currentFilters.copy(showNotes = value)
                    "showBirthdays" -> currentFilters.copy(showBirthdays = value)
                    else -> currentFilters
                }
                
                // Atualizar o estado imediatamente
                _uiState.update { it.copy(filterOptions = newFilters) }
                
                // Atualizar a UI
                updateAllDateDependentUI()
                
                viewModelScope.launch {
                    settingsRepository.saveFilterOptions(newFilters)
                }
            }
        }
    }

    fun onThemeChange(newTheme: Theme) {
        viewModelScope.launch {
            settingsRepository.saveTheme(newTheme)
        }
    }



    fun onSaveActivity(activityData: Activity, syncWithGoogle: Boolean = false) {
        viewModelScope.launch {
            // Verificar se √© uma edi√ß√£o de inst√¢ncia recorrente
            val isEditingRecurringInstance = activityData.id.contains("_") && 
                                           activityData.id != "new" && 
                                           !activityData.id.isBlank()

            
            if (isEditingRecurringInstance) {
                // √â uma edi√ß√£o de inst√¢ncia recorrente - aplicar mudan√ßas √† atividade base
                val baseId = activityData.id.split("_").first()
                val baseActivity = _uiState.value.activities.find { it.id == baseId }
                
                if (baseActivity != null) {
                    // Aplicar mudan√ßas √† atividade base, mantendo o ID original
                    val updatedBaseActivity = baseActivity.copy(
                        title = activityData.title,
                        description = activityData.description,
                        startTime = activityData.startTime,
                        endTime = activityData.endTime,
                        isAllDay = activityData.isAllDay,
                        location = activityData.location,
                        categoryColor = activityData.categoryColor,
                        notificationSettings = activityData.notificationSettings,
                        visibility = activityData.visibility,
                        showInCalendar = activityData.showInCalendar
                        // N√ÉO alterar recurrenceRule para manter a recorr√™ncia
                    )
                    
                    // Salvar a atividade base atualizada
                    activityRepository.saveActivity(updatedBaseActivity)
                    
                    // Agendar notifica√ß√£o se configurada - usar a inst√¢ncia espec√≠fica com data correta
                    if (activityData.notificationSettings.isEnabled &&
                        activityData.notificationSettings.notificationType != com.mss.thebigcalendar.data.model.NotificationType.NONE) {
                        
                        // Extrair a data da inst√¢ncia espec√≠fica do ID
                        val instanceDate = activityData.id.split("_").getOrNull(1)
                        if (instanceDate != null) {
                            // Criar uma c√≥pia da atividade com a data correta da inst√¢ncia
                            val instanceActivity = activityData.copy(date = instanceDate)
                            val notificationService = NotificationService(getApplication())
                            notificationService.scheduleNotification(instanceActivity)
                        }
                    }
                    
                    // Sincronizar com Google Calendar se for evento do Google
                    if (updatedBaseActivity.isFromGoogle) {
                        updateGoogleCalendarEvent(updatedBaseActivity)
                    }
                    
                    closeCreateActivityModal()
                    return@launch
                }
            }
            
            // L√≥gica original para atividades n√£o recorrentes ou novas
            var activityToSave = if (activityData.id == "new" || activityData.id.isBlank()) {
                activityData.copy(id = UUID.randomUUID().toString())
            } else {
                activityData
            }

            // Verificar se √© uma edi√ß√£o de atividade existente do Google
            val isEditingGoogleEvent = activityToSave.id != "new" &&
                                     _uiState.value.activities.any { it.id == activityToSave.id && it.isFromGoogle }

            // Se for uma edi√ß√£o de atividade existente, verificar se a repeti√ß√£o foi alterada
            val existingActivity = if (activityToSave.id != "new") {
                _uiState.value.activities.find { it.id == activityToSave.id }
            } else null

            val repetitionChanged = existingActivity?.let { existing ->
                existing.recurrenceRule != activityToSave.recurrenceRule
            } ?: false

            // Se a repeti√ß√£o foi removida, remover todas as inst√¢ncias recorrentes
            if (repetitionChanged && (activityToSave.recurrenceRule.isNullOrEmpty() || activityToSave.recurrenceRule == "NONE")) {
                println("üîÑ Repeti√ß√£o removida para atividade: ${existingActivity!!.title}")
                println("üîÑ Regra anterior: ${existingActivity.recurrenceRule}")
                println("üîÑ Nova regra: ${activityToSave.recurrenceRule}")
                removeRecurringInstances(existingActivity)
            }

            // Se for nova e o usu√°rio optou por sincronizar com Google, tentar inserir primeiro no Google
            val isNewActivity = activityData.id == "new" || activityData.id.isBlank()
            if (isNewActivity && syncWithGoogle) {
                val account = _uiState.value.googleSignInAccount
                if (account != null) {
                    try {
                        val googleEventId = insertGoogleCalendarEvent(activityToSave, account)
                        if (!googleEventId.isNullOrBlank()) {
                            // Usar o ID do Google e marcar como vindo do Google para habilitar atualiza√ß√µes/exclus√µes
                            activityToSave = activityToSave.copy(id = googleEventId, isFromGoogle = true)
                        }
                    } catch (e: Exception) {
                        Log.e("CalendarViewModel", "‚ùå Falha ao inserir no Google Calendar", e)
                    }
                }
            }

            // Salvar a atividade principal (com poss√≠vel ID do Google)
            activityRepository.saveActivity(activityToSave)

            // ‚úÖ Agendar notifica√ß√£o se configurada
            Log.d("CalendarViewModel", "üîî Verificando configura√ß√µes de notifica√ß√£o para: ${activityToSave.title}")
            Log.d("CalendarViewModel", "üîî Notifica√ß√£o habilitada: ${activityToSave.notificationSettings.isEnabled}")
            Log.d("CalendarViewModel", "üîî Tipo de notifica√ß√£o: ${activityToSave.notificationSettings.notificationType}")
            
            if (activityToSave.notificationSettings.isEnabled &&
                activityToSave.notificationSettings.notificationType != com.mss.thebigcalendar.data.model.NotificationType.NONE) {

                Log.d("CalendarViewModel", "üîî Agendando notifica√ß√£o para atividade: ${activityToSave.title}")
                
                // Para atividades repetitivas, agendar notifica√ß√£o para a data selecionada
                val activityForNotification = if (activityToSave.recurrenceRule?.isNotEmpty() == true) {
                    // Se √© uma atividade repetitiva, usar a data selecionada no calend√°rio
                    activityToSave.copy(date = _uiState.value.selectedDate.toString())
                } else {
                    // Se n√£o √© repetitiva, usar a data original
                    activityToSave
                }

                Log.d("CalendarViewModel", "üîî Data da notifica√ß√£o: ${activityForNotification.date}")
                Log.d("CalendarViewModel", "üîî Hor√°rio da atividade: ${activityForNotification.startTime}")
                
                val notificationService = NotificationService(getApplication())
                notificationService.scheduleNotification(activityForNotification)
                
                Log.d("CalendarViewModel", "üîî Notifica√ß√£o agendada com sucesso!")
            } else {
                Log.d("CalendarViewModel", "üîî Notifica√ß√£o n√£o agendada - configura√ß√µes desabilitadas")
            }

            // NOTA: N√£o geramos mais inst√¢ncias repetitivas automaticamente
            // As tarefas repetitivas ser√£o calculadas dinamicamente quando o usu√°rio navegar pelos meses
            if (activityToSave.recurrenceRule?.isNotEmpty() == true && activityToSave.recurrenceRule != "CUSTOM") {
            }

            // Sincronizar com Google Calendar se for edi√ß√£o de evento existente
            if (isEditingGoogleEvent) {
                updateGoogleCalendarEvent(activityToSave)
            }

            // Recarregar atividades do m√™s atual ap√≥s salvar
            loadActivitiesForCurrentMonth()
            
            closeCreateActivityModal()
        }
    }

    /**
     * Calcula inst√¢ncias repetitivas para uma data espec√≠fica
     */
    private fun calculateRecurringInstancesForDate(baseActivity: Activity, targetDate: LocalDate): List<Activity> {
        val instances = mutableListOf<Activity>()
        
        try {
            val baseDate = LocalDate.parse(baseActivity.date)
            val targetDateString = targetDate.toString()
            
            // Verificar se esta data espec√≠fica foi exclu√≠da
            if (baseActivity.excludedDates.contains(targetDateString)) {
                return instances
            }
            
            // Se a data base √© posterior √† data alvo, n√£o h√° inst√¢ncias
            if (baseDate.isAfter(targetDate)) {
                return instances
            }
            
            when (baseActivity.recurrenceRule) {
                "DAILY" -> {
                    // Verificar se a data alvo √© um m√∫ltiplo de dias a partir da data base
                    val daysDiff = ChronoUnit.DAYS.between(baseDate, targetDate)
                    if (daysDiff > 0) {
                        val instance = baseActivity.copy(
                            id = "${baseActivity.id}_${targetDate}",
                            date = targetDate.toString()
                        )
                        instances.add(instance)
                    }
                }
                "WEEKLY" -> {
                    // Verificar se a data alvo √© um m√∫ltiplo de semanas a partir da data base
                    val daysDiff = ChronoUnit.DAYS.between(baseDate, targetDate)
                    if (daysDiff > 0 && daysDiff % 7 == 0L) {
                        val instance = baseActivity.copy(
                            id = "${baseActivity.id}_${targetDate}",
                            date = targetDate.toString()
                        )
                        instances.add(instance)
                    }
                }
                "MONTHLY" -> {
                    // Verificar se a data alvo √© um m√∫ltiplo de meses a partir da data base
                    val monthsDiff = ChronoUnit.MONTHS.between(baseDate, targetDate)
                    if (monthsDiff > 0) {
                        // Manter o mesmo dia do m√™s, ajustando para meses com menos dias
                        val targetDay = minOf(baseDate.dayOfMonth, targetDate.lengthOfMonth())
                        val adjustedDate = targetDate.withDayOfMonth(targetDay)
                        
                        if (adjustedDate.isEqual(targetDate)) {
                            val instance = baseActivity.copy(
                                id = "${baseActivity.id}_${targetDate}",
                                date = targetDate.toString()
                            )
                            instances.add(instance)
                        }
                    }
                }
                "YEARLY" -> {
                    // Verificar se a data alvo √© um m√∫ltiplo de anos a partir da data base
                    val yearsDiff = ChronoUnit.YEARS.between(baseDate, targetDate)
                    if (yearsDiff > 0) {
                        val instance = baseActivity.copy(
                            id = "${baseActivity.id}_${targetDate}",
                            date = targetDate.toString()
                        )
                        instances.add(instance)
                    }
                }
            }
        } catch (e: Exception) {
            // Erro ao calcular inst√¢ncias repetitivas - retornar lista vazia
        }
        
        return instances
    }

    /**
     * Remove todas as inst√¢ncias recorrentes de uma atividade
     */
    private fun removeRecurringInstances(baseActivity: Activity) {
        viewModelScope.launch {
            try {
                // Buscar todas as atividades que s√£o inst√¢ncias desta atividade base
                val allActivities = _uiState.value.activities
                
                val instancesToRemove = allActivities.filter { activity ->
                    // Verificar se √© uma inst√¢ncia recorrente (ID cont√©m o ID base + data)
                    val isInstance = activity.id.startsWith("${baseActivity.id}_") && 
                                   activity.id != baseActivity.id
                    isInstance
                }
                
                // Remover todas as inst√¢ncias
                instancesToRemove.forEach { instance ->
                    activityRepository.deleteActivity(instance.id)
                }
                
            } catch (e: Exception) {
                println("‚ùå Erro ao remover inst√¢ncias recorrentes: ${e.message}")
                e.printStackTrace()
            }
        }
    }

    /**
     * Atualiza um evento no Google Calendar quando ele √© editado no app
     */
    private fun updateGoogleCalendarEvent(activity: Activity) {
        viewModelScope.launch {
            try {
                val account = _uiState.value.googleSignInAccount
                if (account != null) {
                    val calendarService = googleCalendarService.getCalendarService(account)
                    
                    withContext(Dispatchers.IO) {
                        try {
                            // Criar objeto de evento do Google Calendar
                            val googleEvent = com.google.api.services.calendar.model.Event().apply {
                                summary = activity.title
                                description = activity.description
                                location = activity.location
                                
                                // Configurar data e hora
                                if (activity.isAllDay) {
                                    start = com.google.api.services.calendar.model.EventDateTime().apply {
                                        date = com.google.api.client.util.DateTime(activity.date)
                                    }
                                    end = com.google.api.services.calendar.model.EventDateTime().apply {
                                        date = com.google.api.client.util.DateTime(activity.date)
                                    }
                                } else {
                                    val startDateTime = java.time.LocalDateTime.of(
                                        java.time.LocalDate.parse(activity.date),
                                        activity.startTime ?: java.time.LocalTime.of(9, 0)
                                    )
                                    val endDateTime = java.time.LocalDateTime.of(
                                        java.time.LocalDate.parse(activity.date),
                                        activity.endTime ?: java.time.LocalTime.of(10, 0)
                                    )
                                    
                                    start = com.google.api.services.calendar.model.EventDateTime().apply {
                                        dateTime = com.google.api.client.util.DateTime(
                                            startDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()
                                        )
                                    }
                                    end = com.google.api.services.calendar.model.EventDateTime().apply {
                                        dateTime = com.google.api.client.util.DateTime(
                                            endDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()
                                        )
                                    }
                                }
                                
                                // Configurar regra de repeti√ß√£o se houver
                                if (!activity.recurrenceRule.isNullOrEmpty()) {
                                    recurrence = listOf(activity.recurrenceRule)
                                }
                            }
                            
                            // Atualizar o evento no Google Calendar
                            calendarService.events().update("primary", activity.id, googleEvent).execute()
                            
                        } catch (e: Exception) {
                            Log.w("CalendarViewModel", "‚ö†Ô∏è N√£o foi poss√≠vel atualizar evento no Google Calendar: ${activity.title}", e)
                        }
                    }
                } else {
                    Log.w("CalendarViewModel", "‚ö†Ô∏è Usu√°rio n√£o est√° logado no Google, n√£o √© poss√≠vel atualizar no Google Calendar")
                }
            } catch (e: Exception) {
                Log.e("CalendarViewModel", "‚ùå Erro ao atualizar evento no Google Calendar: ${activity.title}", e)
            }
        }
    }

    /**
     * Insere um novo evento no Google Calendar e retorna o ID do evento criado
     */
    private suspend fun insertGoogleCalendarEvent(activity: Activity, account: GoogleSignInAccount): String? {
        return withContext(Dispatchers.IO) {
            try {
                val calendarService = googleCalendarService.getCalendarService(account)

                val googleEvent = com.google.api.services.calendar.model.Event().apply {
                    summary = activity.title
                    description = activity.description
                    location = activity.location

                    // Datas/hor√°rios
                    if (activity.isAllDay) {
                        start = com.google.api.services.calendar.model.EventDateTime().apply {
                            date = com.google.api.client.util.DateTime(activity.date)
                        }
                        end = com.google.api.services.calendar.model.EventDateTime().apply {
                            date = com.google.api.client.util.DateTime(activity.date)
                        }
                    } else {
                        val startDateTime = java.time.LocalDateTime.of(
                            java.time.LocalDate.parse(activity.date),
                            activity.startTime ?: java.time.LocalTime.of(9, 0)
                        )
                        val endDateTime = java.time.LocalDateTime.of(
                            java.time.LocalDate.parse(activity.date),
                            activity.endTime ?: (activity.startTime?.plusHours(1) ?: java.time.LocalTime.of(10, 0))
                        )

                        start = com.google.api.services.calendar.model.EventDateTime().apply {
                            dateTime = com.google.api.client.util.DateTime(
                                startDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()
                            )
                        }
                        end = com.google.api.services.calendar.model.EventDateTime().apply {
                            dateTime = com.google.api.client.util.DateTime(
                                endDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()
                            )
                        }
                    }

                    // Regra de repeti√ß√£o: para anivers√°rios, padronizar YEARLY se n√£o houver
                    when (activity.activityType) {
                        com.mss.thebigcalendar.data.model.ActivityType.BIRTHDAY -> {
                            val rule = activity.recurrenceRule?.takeIf { it.isNotEmpty() } ?: "RRULE:FREQ=YEARLY"
                            recurrence = listOf(rule)
                        }
                        else -> {
                            if (!activity.recurrenceRule.isNullOrEmpty()) {
                                recurrence = listOf(activity.recurrenceRule)
                            }
                        }
                    }
                }

                val created = calendarService.events().insert("primary", googleEvent).execute()
                created?.id
            } catch (e: Exception) {
                Log.e("CalendarViewModel", "‚ùå Erro ao inserir evento no Google Calendar", e)
                null
            }
        }
    }

    /**
     * Deleta um evento do Google Calendar quando ele √© removido do app
     */
    private fun deleteFromGoogleCalendar(activity: Activity) {
        viewModelScope.launch {
            try {
                val account = _uiState.value.googleSignInAccount
                if (account != null) {
                    val calendarService = googleCalendarService.getCalendarService(account)
                    
                    // Tentar deletar o evento usando o ID original do Google
                    withContext(Dispatchers.IO) {
                        try {
                            calendarService.events().delete("primary", activity.id).execute()
                        } catch (e: Exception) {
                            Log.w("CalendarViewModel", "‚ö†Ô∏è N√£o foi poss√≠vel deletar evento do Google Calendar: ${activity.title}", e)
                            
                            // Se falhar, tentar buscar o evento pelo t√≠tulo e data
                            try {
                                val events = calendarService.events().list("primary")
                                    .setQ(activity.title) // Buscar por t√≠tulo
                                    .setTimeMin(com.google.api.client.util.DateTime(Instant.parse("${activity.date}T00:00:00Z").toEpochMilli()))
                                    .setTimeMax(com.google.api.client.util.DateTime(Instant.parse("${activity.date}T23:59:59Z").toEpochMilli()))
                                    .execute()
                                
                                events.items?.forEach { event ->
                                    if (event.summary == activity.title) {
                                        calendarService.events().delete("primary", event.id).execute()
                                    }
                                }
                            } catch (searchException: Exception) {
                                Log.e("CalendarViewModel", "‚ùå Falha ao buscar e deletar evento do Google Calendar: ${activity.title}", searchException)
                            }
                        }
                    }
                } else {
                    Log.w("CalendarViewModel", "‚ö†Ô∏è Usu√°rio n√£o est√° logado no Google, n√£o √© poss√≠vel deletar do Google Calendar")
                }
            } catch (e: Exception) {
                Log.e("CalendarViewModel", "‚ùå Erro ao deletar evento do Google Calendar: ${activity.title}", e)
            }
        }
    }

    fun onDeleteActivityConfirm() {
        viewModelScope.launch {
            _uiState.value.activityIdToDelete?.let { activityId ->
                // Buscar a atividade pelo ID ou, se for inst√¢ncia recorrente, buscar pela atividade base
                var activityToDelete = _uiState.value.activities.find { it.id == activityId }
                
                // Se n√£o encontrou pelo ID e parece ser uma inst√¢ncia recorrente, buscar pela atividade base
                if (activityToDelete == null && activityId.contains("_")) {
                    val baseId = activityId.split("_").first()
                    activityToDelete = _uiState.value.activities.find { it.id == baseId }
                }
                
                // Se ainda n√£o encontrou, buscar por t√≠tulo e regra de recorr√™ncia
                if (activityToDelete == null && activityId.contains("_")) {
                    val baseId = activityId.split("_").first()
                    val allActivities = _uiState.value.activities
                    activityToDelete = allActivities.find { 
                        it.id == baseId || 
                        (it.id.contains(baseId) && it.id.contains("_"))
                    }
                }
                
                if (activityToDelete != null) {
                    // ‚úÖ Cancelar notifica√ß√£o antes de deletar
                    val notificationService = NotificationService(getApplication())
                    notificationService.cancelNotification(activityId)
                    
                    // Se √© uma atividade recorrente, deletar todas as inst√¢ncias
                    if (recurrenceService.isRecurring(activityToDelete)) {
                        val allActivities = _uiState.value.activities
                        val recurringActivities = allActivities.filter { 
                            it.title == activityToDelete.title && 
                            it.recurrenceRule == activityToDelete.recurrenceRule
                        }
                        
                        // Mover todas as inst√¢ncias para a lixeira
                        recurringActivities.forEach { activity ->
                            deletedActivityRepository.addDeletedActivity(activity)
                            activityRepository.deleteActivity(activity.id)
                            
                            // Sincronizar com Google Calendar se for evento do Google
                            if (activity.isFromGoogle) {
                                deleteFromGoogleCalendar(activity)
                            }
                        }
                        
                    } else {
                        // Mover para a lixeira
                        deletedActivityRepository.addDeletedActivity(activityToDelete)
                        
                        // Deletar da lista principal
                        activityRepository.deleteActivity(activityId)
                        
                        // Sincronizar com Google Calendar se for evento do Google
                        if (activityToDelete.isFromGoogle) {
                            deleteFromGoogleCalendar(activityToDelete)
                        }
                        
                    }
                }
            }
            cancelDeleteActivity()
        }
    }

    

    fun onBackupRequest() {
        viewModelScope.launch {
            try {
                // Verificar permiss√µes antes de fazer backup
                if (!backupService.hasStoragePermission()) {
                    _uiState.update { it.copy(
                        backupMessage = "Permiss√£o de armazenamento necess√°ria para backup",
                        needsStoragePermission = true
                    ) }
                    return@launch
                }
                
                val result = backupService.createBackup()
                result.fold(
                    onSuccess = { backupPath ->
                        // Atualizar o estado para mostrar sucesso
                        _uiState.update { it.copy(
                            backupMessage = "Backup criado com sucesso: ${backupPath.substringAfterLast("/")}"
                        ) }
                        // Recarregar lista de backups
                        loadBackupFiles()
                    },
                    onFailure = { exception ->
                        Log.e("CalendarViewModel", "‚ùå Erro ao criar backup", exception)
                        // Atualizar o estado para mostrar erro
                        _uiState.update { it.copy(
                            backupMessage = "Erro ao criar backup: ${exception.message}"
                        ) }
                    }
                )
            } catch (e: Exception) {
                Log.e("CalendarViewModel", "‚ùå Erro inesperado durante backup", e)
                _uiState.update { it.copy(
                    backupMessage = "Erro inesperado: ${e.message}"
                ) }
            }
        }
    }
    
    fun clearBackupMessage() {
        _uiState.update { it.copy(backupMessage = null, needsStoragePermission = false) }
    }
    fun onRestoreRequest() { println("ViewModel: Pedido de restaura√ß√£o recebido.") }

    fun openSidebar() = _uiState.update { it.copy(isSidebarOpen = true) }
    fun closeSidebar() = _uiState.update { it.copy(isSidebarOpen = false) }

    fun onNavigateToSettings(screen: String?) {
        _uiState.update { it.copy(isSettingsScreenOpen = true, isSidebarOpen = false) }
    }

    fun closeSettingsScreen() {
        _uiState.update { it.copy(isSettingsScreenOpen = false) }
    }

    fun onWelcomeNameChange(newName: String) {
        viewModelScope.launch {
            settingsRepository.saveWelcomeName(newName)
        }
    }

    fun openCreateActivityModal(activity: Activity? = null, activityType: ActivityType = ActivityType.EVENT) {
        val template = if (activity != null) {
            // Se for uma inst√¢ncia recorrente, carregar os dados da atividade base
            if (activity.id.contains("_") && activity.id != "new") {
                val baseId = activity.id.split("_").first()
                val baseActivity = _uiState.value.activities.find { it.id == baseId }
                baseActivity ?: activity
            } else {
                activity
            }
        } else {
            Activity(
                id = "new",
                title = "",
                description = null,
                date = _uiState.value.selectedDate.toString(),
                startTime = null,
                endTime = null,
                isAllDay = true,
                location = null,
                categoryColor = if (activityType == ActivityType.TASK) "#3B82F6" else "#F43F5E",
                activityType = activityType,
                recurrenceRule = null,
                showInCalendar = true // Por padr√£o, mostrar no calend√°rio
            )
        }
        _uiState.update { it.copy(activityToEdit = template, activityIdWithDeleteButtonVisible = null) }
    }

    fun closeCreateActivityModal() = _uiState.update { it.copy(activityToEdit = null) }

    fun onTaskLongPressed(activityId: String) {
        _uiState.update { currentState ->
            if (currentState.activityIdWithDeleteButtonVisible == activityId) {
                // If the same item is clicked again, hide the buttons
                currentState.copy(activityIdWithDeleteButtonVisible = null)
            } else {
                // Otherwise, show buttons for the new item
                currentState.copy(activityIdWithDeleteButtonVisible = activityId)
            }
        }
    }

    fun hideDeleteButton() {
        _uiState.update { it.copy(activityIdWithDeleteButtonVisible = null) }
    }
    
    fun markActivityAsCompleted(activityId: String) {
        viewModelScope.launch {
            markActivityAsCompletedInternal(activityId)
        }
    }
    
    /**
     * Fun√ß√£o interna para marcar atividade como conclu√≠da (pode ser chamada por notifica√ß√µes)
     */
    fun markActivityAsCompletedInternal(activityId: String) {
        viewModelScope.launch {
            
            // Verificar se √© uma inst√¢ncia recorrente (ID cont√©m data)
            val isRecurringInstance = activityId.contains("_") && activityId.split("_").size == 2
            
            if (isRecurringInstance) {
                // Tratar inst√¢ncia recorrente espec√≠fica
                val parts = activityId.split("_")
                val baseId = parts[0]
                val instanceDate = parts[1]

                
                // Buscar a atividade base
                val baseActivity = _uiState.value.activities.find { it.id == baseId }
                
                if (baseActivity != null && recurrenceService.isRecurring(baseActivity)) {

                    
                    // Criar inst√¢ncia espec√≠fica para salvar como conclu√≠da
                    val instanceToComplete = baseActivity.copy(
                        id = activityId,
                        date = instanceDate,
                        isCompleted = true,
                        showInCalendar = false
                    )
                    
                    // Salvar inst√¢ncia espec√≠fica como conclu√≠da
                    completedActivityRepository.addCompletedActivity(instanceToComplete)
                    
                    // Adicionar data √† lista de exclus√µes da atividade base
                    val updatedExcludedDates = baseActivity.excludedDates + instanceDate
                    val updatedBaseActivity = baseActivity.copy(excludedDates = updatedExcludedDates)
                    
                    // Atualizar a atividade base com a nova lista de exclus√µes
                    activityRepository.saveActivity(updatedBaseActivity)

                    
                    // Atualizar a UI
                    updateAllDateDependentUI()
                    
                }
            } else {
                // Tratar atividade √∫nica ou atividade base
                val activityToComplete = _uiState.value.activities.find { it.id == activityId }
                
                if (activityToComplete != null) {
                    // Verificar se √© uma atividade recorrente
                    if (recurrenceService.isRecurring(activityToComplete)) {
                        // Para atividades recorrentes (primeira inst√¢ncia), sempre tratar como inst√¢ncia espec√≠fica
                        val activityDate = activityToComplete.date

                        
                        // Criar inst√¢ncia espec√≠fica para salvar como conclu√≠da
                        val instanceToComplete = activityToComplete.copy(
                            id = activityId,
                            date = activityDate,
                            isCompleted = true,
                            showInCalendar = false
                        )
                        
                        // Salvar inst√¢ncia espec√≠fica como conclu√≠da
                        completedActivityRepository.addCompletedActivity(instanceToComplete)
                        
                        // Adicionar data √† lista de exclus√µes da atividade base
                        val updatedExcludedDates = activityToComplete.excludedDates + activityDate
                        val updatedBaseActivity = activityToComplete.copy(excludedDates = updatedExcludedDates)
                        
                        // Atualizar a atividade base com a nova lista de exclus√µes
                        activityRepository.saveActivity(updatedBaseActivity)

                        
                        // Atualizar a UI
                        updateAllDateDependentUI()
                        
                    } else {
                        // Tratar atividade √∫nica (n√£o recorrente)
                        
                        // Marcar como conclu√≠da e salvar no reposit√≥rio de finalizadas
                        val completedActivity = activityToComplete.copy(
                            isCompleted = true,
                            showInCalendar = false // Ocultar do calend√°rio mensal
                        )
                        
                        // Salvar no reposit√≥rio de atividades finalizadas
                        completedActivityRepository.addCompletedActivity(completedActivity)
                        
                        // Remover da lista principal
                        activityRepository.deleteActivity(activityId)
                        
                        // Sincronizar com Google Calendar se for evento do Google
                        if (activityToComplete.isFromGoogle) {
                            deleteFromGoogleCalendar(activityToComplete)
                        }

                        
                        // Atualizar a UI ap√≥s marcar como conclu√≠da
                        updateAllDateDependentUI()
                    }
                }
            }
        }
    }

    fun requestDeleteActivity(activityId: String) {
        _uiState.update { it.copy(activityIdToDelete = activityId, activityIdWithDeleteButtonVisible = null) }
    }

    fun cancelDeleteActivity() = _uiState.update { it.copy(activityIdToDelete = null) }

    fun onSaintDayClick(saint: Holiday) {
        _uiState.update { it.copy(saintInfoToShow = saint) }
    }

    fun onSaintInfoDialogDismiss() {
        _uiState.update { it.copy(saintInfoToShow = null) }
    }

    // Fun√ß√µes de pesquisa
    fun onSearchQueryChange(query: String) {
        println("üîç Pesquisando por: '$query'")
        _uiState.update { it.copy(searchQuery = query) }
        
        if (query.isBlank()) {
            _uiState.update { it.copy(searchResults = emptyList()) }
            return
        }
        
        // Verificar dados dispon√≠veis
        println("üìä Dados dispon√≠veis para pesquisa:")
        println("  - Atividades: ${_uiState.value.activities.size}")
        println("  - Feriados nacionais: ${_uiState.value.nationalHolidays.size}")
        println("  - Dias de santos: ${_uiState.value.saintDays.size}")
        println("  - Datas comemorativas: ${_uiState.value.commemorativeDates.size}")
        
        // Realizar pesquisa
        val results = searchService.search(
            query = query,
            activities = _uiState.value.activities,
            nationalHolidays = _uiState.value.nationalHolidays,
            saintDays = _uiState.value.saintDays,
            commemorativeDates = _uiState.value.commemorativeDates
        )
        
        println("üîç Resultados encontrados: ${results.size}")
        results.forEach { result ->
            println("  - ${result.title} (${result.type})")
        }
        
        _uiState.update { it.copy(searchResults = results) }
    }

    fun onSearchResultClick(result: SearchResult) {
        println("üéØ Resultado selecionado: ${result.title} (${result.type})")
        result.date?.let { targetDate ->
            println("üìÖ Navegando para data: $targetDate")
            // Navegar para o m√™s da data encontrada
            val targetYearMonth = java.time.YearMonth.from(targetDate)
            _uiState.update { 
                it.copy(
                    displayedYearMonth = targetYearMonth,
                    selectedDate = targetDate
                )
            }
            
            // Atualizar a UI para mostrar o m√™s correto
            updateAllDateDependentUI()
        }
        
        // Limpar pesquisa
        _uiState.update { 
            it.copy(
                searchQuery = "",
                searchResults = emptyList()
            )
        }
    }

    fun clearSearch() {
        _uiState.update { 
            it.copy(
                searchQuery = "",
                searchResults = emptyList()
            )
        }
    }

    fun onSearchIconClick() {
        println("üîç Abrindo tela de pesquisa")
        _uiState.update { it.copy(isSearchScreenOpen = true) }
    }

    fun onChartIconClick() {
        println("üìä Abrindo tela de gr√°fico")
        _uiState.update { it.copy(isChartScreenOpen = true) }
    }

        fun closeSearchScreen() {
        println("üö™ Fechando tela de pesquisa")
        _uiState.update {
            it.copy(
                isSearchScreenOpen = false,
                searchQuery = "",
                searchResults = emptyList()
            )
        }
    }

    fun closeChartScreen() {
        println("üö™ Fechando tela de gr√°fico")
        _uiState.update { it.copy(isChartScreenOpen = false) }
    }

    // --- Tela de Notas ---
    fun onNotesClick() {
        println("üìù Abrindo tela de notas")
        _uiState.update { it.copy(isNotesScreenOpen = true, isSidebarOpen = false) }
    }

    fun closeNotesScreen() {
        println("üö™ Fechando tela de notas")
        _uiState.update { it.copy(isNotesScreenOpen = false) }
    }

    // --- Tarefas Conclu√≠das ---
    fun onCompletedTasksClick() {
        println("üìã Abrindo tela de tarefas conclu√≠das")
        _uiState.update { it.copy(isCompletedTasksScreenOpen = true) }
    }

    fun closeCompletedTasksScreen() {
        println("üö™ Fechando tela de tarefas conclu√≠das")
        _uiState.update { it.copy(isCompletedTasksScreenOpen = false) }
    }

    // --- Lixeira ---
    
    fun onTrashIconClick() {
        println("üóëÔ∏è Abrindo lixeira")
        _uiState.update { it.copy(isTrashScreenOpen = true) }
    }
    
    fun onTrashSortOrderChange(sortOrder: String) {
        println("üîÑ Alterando ordem da lixeira: $sortOrder")
        _uiState.update { it.copy(trashSortOrder = sortOrder) }
    }
    
    fun forceGoogleSync() {
        val account = _uiState.value.googleSignInAccount
        if (account != null) {
            fetchGoogleCalendarEvents(account, forceSync = true)
        }
    }
    
    fun manualGoogleSync() {
        val account = _uiState.value.googleSignInAccount
        if (account != null) {
            fetchGoogleCalendarEvents(account, forceSync = true)
        }
    }
    
    fun onManualSync() {
        val account = _uiState.value.googleSignInAccount
        if (account != null) {
            Log.d("CalendarViewModel", "üîÑ Sincroniza√ß√£o manual progressiva solicitada")
            performProgressiveSync(account)
        }
    }
    
    private fun performProgressiveSync(account: GoogleSignInAccount) {
        viewModelScope.launch {
            _uiState.update { it.copy(isSyncing = true, syncErrorMessage = null, syncProgress = null) }
            
            try {
                val result = progressiveSyncService.syncProgressively(account) { progress ->
                    _uiState.update { it.copy(syncProgress = progress) }
                }
                
                result.fold(
                    onSuccess = { totalEvents ->
                        Log.d("CalendarViewModel", "‚úÖ Sincroniza√ß√£o progressiva conclu√≠da: $totalEvents eventos")
                        _uiState.update { it.copy(
                            isSyncing = false,
                            lastGoogleSyncTime = System.currentTimeMillis()
                        ) }
                        
                        // Agendar pr√≥xima sincroniza√ß√£o autom√°tica
                        scheduleAutomaticSync()
                        
                        updateAllDateDependentUI()
                    },
                    onFailure = { exception ->
                        Log.e("CalendarViewModel", "‚ùå Erro na sincroniza√ß√£o progressiva", exception)
                        _uiState.update { it.copy(
                            isSyncing = false,
                            syncErrorMessage = "Falha na sincroniza√ß√£o: ${exception.message}"
                        ) }
                    }
                )
                
            } catch (e: Exception) {
                Log.e("CalendarViewModel", "‚ùå Erro inesperado na sincroniza√ß√£o", e)
                _uiState.update { it.copy(
                    isSyncing = false,
                    syncErrorMessage = "Erro inesperado: ${e.message}"
                ) }
            }
        }
    }
    
    /**
     * Agenda sincroniza√ß√£o autom√°tica di√°ria
     */
    private fun scheduleAutomaticSync() {
        val workManager = WorkManager.getInstance(getApplication())
        
        // Cancelar trabalhos anteriores
        workManager.cancelAllWorkByTag("google_calendar_sync")
        
        // Criar restri√ß√µes (s√≥ sincronizar com internet)
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
        
        // Agendar sincroniza√ß√£o di√°ria
        val syncWorkRequest = PeriodicWorkRequestBuilder<GoogleCalendarSyncWorker>(
            1, TimeUnit.DAYS
        )
            .setConstraints(constraints)
            .addTag("google_calendar_sync")
            .build()
        
        workManager.enqueue(syncWorkRequest)
        Log.d("CalendarViewModel", "üìÖ Sincroniza√ß√£o autom√°tica agendada para executar diariamente")
    }
    
    fun closeTrashScreen() {
        println("üö™ Fechando lixeira")
        _uiState.update { it.copy(isTrashScreenOpen = false) }
    }
    
    fun restoreDeletedActivity(deletedActivityId: String) {
        viewModelScope.launch {
            val restoredActivity = deletedActivityRepository.restoreActivity(deletedActivityId)
            if (restoredActivity != null) {
                // Restaurar a atividade
                activityRepository.addActivity(restoredActivity)
                println("‚úÖ Atividade restaurada: ${restoredActivity.title}")
            }
        }
    }

    private suspend fun ActivityRepository.addActivity(activity: Activity) {
        saveActivity(activity)
    }

    fun removeDeletedActivity(deletedActivityId: String) {
        viewModelScope.launch {
            deletedActivityRepository.removeDeletedActivity(deletedActivityId)
            println("üóëÔ∏è Atividade removida permanentemente da lixeira")
        }
    }
    
    fun clearAllDeletedActivities() {
        viewModelScope.launch {
            deletedActivityRepository.clearAllDeletedActivities()
            println("üóëÔ∏è Lixeira esvaziada")
        }
    }
    
    // --- Tarefas Finalizadas ---
    
    fun toggleCompletedActivitiesVisibility() {
        _uiState.update { it.copy(showCompletedActivities = !it.showCompletedActivities) }
        updateAllDateDependentUI()
    }
    
    fun toggleMoonPhasesVisibility() {
        _uiState.update { it.copy(showMoonPhases = !it.showMoonPhases) }
    }
    
    fun getCompletedActivities(): List<Activity> {
        return _uiState.value.completedActivities
    }
    
    /**
     * Calcula os dados para o gr√°fico de barras dos √∫ltimos 7 dias
     */
    fun getLast7DaysCompletedTasksData(): List<com.mss.thebigcalendar.ui.components.BarChartData> {
        val today = LocalDate.now()
        val completedActivities = _uiState.value.completedActivities
        
        // Criar lista dos √∫ltimos 7 dias
        val last7Days = (0..6).map { daysAgo ->
            today.minusDays(daysAgo.toLong())
        }.reversed() // Do mais antigo para o mais recente
        
        return last7Days.map { date ->
            val dateString = date.toString()
            val count = completedActivities.count { activity ->
                activity.date == dateString
            }
            
            // Formatar o label do dia (ex: "Seg", "Ter", etc.)
            val dayLabel = when (date.dayOfWeek.value) {
                1 -> "Seg"
                2 -> "Ter" 
                3 -> "Qua"
                4 -> "Qui"
                5 -> "Sex"
                6 -> "S√°b"
                7 -> "Dom"
                else -> date.dayOfWeek.name.take(3)
            }
            
            com.mss.thebigcalendar.ui.components.BarChartData(
                label = dayLabel,
                value = count,
                color = when (count) {
                    0 -> Color(0xFF79747E) // outline color
                    in 1..2 -> Color(0xFF6750A4) // primary color
                    in 3..5 -> Color(0xFF625B71) // secondary color
                    else -> Color(0xFF7D5260) // tertiary color
                }
            )
        }
    }
    
    /**
     * Calcula os dados para o gr√°fico de barras do √∫ltimo ano (12 meses)
     */
    fun getLastYearCompletedTasksData(): List<com.mss.thebigcalendar.ui.components.BarChartData> {
        val today = LocalDate.now()
        val completedActivities = _uiState.value.completedActivities
        
        // Criar lista dos √∫ltimos 12 meses
        val last12Months = (0..11).map { monthsAgo ->
            today.minusMonths(monthsAgo.toLong())
        }.reversed() // Do mais antigo para o mais recente
        
        return last12Months.map { date ->
            val yearMonth = "${date.year}-${date.monthValue.toString().padStart(2, '0')}"
            val count = completedActivities.count { activity ->
                activity.date.startsWith(yearMonth)
            }
            
            // Formatar o label do m√™s (ex: "Jan", "Fev", etc.)
            val monthLabel = when (date.monthValue) {
                1 -> "Jan"
                2 -> "Fev"
                3 -> "Mar"
                4 -> "Abr"
                5 -> "Mai"
                6 -> "Jun"
                7 -> "Jul"
                8 -> "Ago"
                9 -> "Set"
                10 -> "Out"
                11 -> "Nov"
                12 -> "Dez"
                else -> date.month.name.take(3)
            }
            
            com.mss.thebigcalendar.ui.components.BarChartData(
                label = monthLabel,
                value = count,
                color = when (count) {
                    0 -> Color(0xFF79747E) // outline color
                    in 1..5 -> Color(0xFF6750A4) // primary color
                    in 6..15 -> Color(0xFF625B71) // secondary color
                    in 16..30 -> Color(0xFF7D5260) // tertiary color
                    else -> Color(0xFF4A148C) // high productivity color
                }
            )
        }
    }
    
    // --- Backup ---
    
    fun onBackupIconClick() {
        println("üíæ Abrindo tela de backup")
        _uiState.update { it.copy(isBackupScreenOpen = true, isSidebarOpen = false) }
    }
    
    fun closeBackupScreen() {
        println("üö™ Fechando tela de backup")
        _uiState.update { it.copy(
            isBackupScreenOpen = false,
            backupMessage = null
        ) }
    }
    
    /**
     * Verifica se o app tem permiss√£o para sobrepor outros apps
     */
    fun hasOverlayPermission(): Boolean {
        return visibilityService.hasOverlayPermission()
    }
    
    /**
     * Solicita permiss√£o para sobrepor outros apps
     */
    fun requestOverlayPermission(): Intent {
        return visibilityService.requestOverlayPermission()
    }
    
    /**
     * Testa o alerta de visibilidade alta
     */
    fun testHighVisibilityAlert() {
        Log.d(TAG, "üß™ Testando alerta de visibilidade alta")
        visibilityService.testHighVisibilityAlert()
    }
    
    fun loadBackupFiles() {
        viewModelScope.launch {
            try {
                val backupFiles = backupService.listBackupFiles()
                val backupInfos = mutableListOf<BackupInfo>()
                
                backupFiles.forEach { file ->
                    val info = backupService.getBackupInfo(file)
                    info.onSuccess { backupInfo ->
                        backupInfos.add(backupInfo)
                    }
                }
                
                _uiState.update { it.copy(backupFiles = backupInfos) }
                println("üìÅ ${backupInfos.size} arquivos de backup carregados")
            } catch (e: Exception) {
                println("‚ùå Erro ao carregar arquivos de backup: ${e.message}")
            }
        }
    }
    
    fun deleteBackupFile(filePath: String) {
        viewModelScope.launch {
            try {
                val file = java.io.File(filePath)
                if (file.exists()) {
                    val deleted = file.delete()
                    if (deleted) {
                        println("üóëÔ∏è Arquivo de backup deletado: $filePath")
                        // Recarregar lista de backups
                        loadBackupFiles()
                        _uiState.update { it.copy(
                            backupMessage = "Backup deletado com sucesso"
                        ) }
                    } else {
                        println("‚ùå Falha ao deletar arquivo de backup: $filePath")
                        _uiState.update { it.copy(
                            backupMessage = "Erro ao deletar backup"
                        ) }
                    }
                }
            } catch (e: Exception) {
                println("‚ùå Erro ao deletar arquivo de backup: ${e.message}")
                _uiState.update { it.copy(
                    backupMessage = "Erro ao deletar backup: ${e.message}"
                ) }
            }
        }
    }
    
    fun restoreFromBackup(filePath: String) {
        viewModelScope.launch {
            try {
                println("üîÑ Iniciando restaura√ß√£o do backup: $filePath")
                _uiState.update { it.copy(
                    backupMessage = "Restaura√ß√£o em andamento..."
                ) }
                
                val backupFile = java.io.File(filePath)
                if (!backupFile.exists()) {
                    _uiState.update { it.copy(
                        backupMessage = "Arquivo de backup n√£o encontrado"
                    ) }
                    return@launch
                }
                
                // Restaurar dados do backup
                val restoreResult = backupService.restoreFromBackup(backupFile)
                restoreResult.fold(
                    onSuccess = { result ->
                        println("‚úÖ Backup restaurado com sucesso:")
                        println("   - Atividades: ${result.activities.size}")
                        println("   - Itens da lixeira: ${result.deletedActivities.size}")
                        println("   - Atividades conclu√≠das: ${result.completedActivities.size}")
                        
                        // Limpar dados atuais
                        clearAllCurrentData()
                        
                        // Restaurar atividades
                        result.activities.forEach { activity ->
                            activityRepository.saveActivity(activity)
                        }
                        
                        // Restaurar itens da lixeira
                        result.deletedActivities.forEach { deletedActivity ->
                            deletedActivityRepository.addDeletedActivity(deletedActivity.originalActivity)
                        }
                        
                        // Restaurar atividades conclu√≠das
                        result.completedActivities.forEach { activity ->
                            completedActivityRepository.addCompletedActivity(activity)
                        }
                        
                        _uiState.update { it.copy(
                            backupMessage = "Backup restaurado com sucesso! ${result.activities.size} atividades, ${result.deletedActivities.size} itens da lixeira e ${result.completedActivities.size} atividades conclu√≠das restaurados."
                        ) }
                        
                        // Recarregar dados da UI
                        loadData()
                        loadBackupFiles()

                        // Reagendar notifica√ß√µes
                        val notificationService = NotificationService(getApplication())
                        result.activities.forEach { activity ->
                            notificationService.scheduleNotification(activity)
                        }
                    },
                    onFailure = { exception ->
                        println("‚ùå Erro ao restaurar backup: ${exception.message}")
                        _uiState.update { it.copy(
                            backupMessage = "Erro ao restaurar backup: ${exception.message}"
                        ) }
                    }
                )
                
            } catch (e: Exception) {
                println("‚ùå Erro inesperado ao restaurar backup: ${e.message}")
                _uiState.update { it.copy(
                    backupMessage = "Erro inesperado: ${e.message}"
                ) }
            }
        }
    }
    
    /**
     * Limpa todos os dados atuais antes da restaura√ß√£o
     */
    private suspend fun clearAllCurrentData() {
        try {
            // Limpar todas as atividades
            val currentActivities = activityRepository.activities.first()
            currentActivities.forEach { activity ->
                activityRepository.deleteActivity(activity.id)
            }
            
            // Limpar lixeira
            deletedActivityRepository.clearAllDeletedActivities()
            
            println("üóëÔ∏è Dados atuais limpos para restaura√ß√£o")
        } catch (e: Exception) {
            println("‚ö†Ô∏è Erro ao limpar dados atuais: ${e.message}")
        }
    }
    

}